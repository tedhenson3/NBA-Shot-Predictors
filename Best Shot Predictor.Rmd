---
title: "Best NBA Shot Predictor using Best Glm function"
author: "Ted Henson"
date: "January 10, 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
#pca
setwd("~/shots")
library(tidyverse)

shots <- read.csv(file = "shots.csv", header = TRUE, stringsAsFactors = F, fill = T)
shots$r <- sqrt(shots$shot_x^2 + shots$shot_y^2)

#22 feet to corner, 23.75 feet on arc
ll <- sqrt(23.75^2 - 22^2)
#shots$is.three <- ((shots$shot_y < ll) & (shots$shot_x > 22)) | (shots$r >= 23.75)



side <- function(x) {
  if (x > 0) {
    result <- "Right"
  }
  else if (x < 0) {
    result <- "Left"
  }
  else {
    result <- "Zero"
  }
  return(result)
}
# shots$courtside <- sapply(shots$shot_x, FUN = side)
# 
# shots$defangleside <- sapply(shots$defender_velocity_angle, FUN = side)
# shots$defangle <- sapply(shots$defender_velocity_angle, FUN = side)
# 
# shots$shootangleside <- sapply(shots$shooter_velocity_angle, FUN = side)
# 
# shots$shootangleside <- factor(shots$shootangleside)
# shots$defangle <- factor(shots$defangle)
# shots$defangleside <- factor(shots$defangleside)
# shots$courtside <- factor(shots$courtside)
# 

set.seed(1991)

shots <- shots[, -c(2,3)]

split <- sample(nrow(shots[,2:c(ncol(shots))]), 8000)
train <- shots[split,]
test <- shots[-split,]
library(boot)  
library(glmnet)

library(bestglm)
library(MASS)


fit <- glmnet(x = as.matrix(train[,2:ncol(train)]), y = as.vector(train$made) ,  family = 'binomial', alpha = .5)


xy <- cbind(train[,2:ncol(train)], train$made)
best <- bestglm(xy, IC = 'AIC')
summary(best)

# library(randomForest)
# rf <- randomForest(made ~ ., data = train)
#step <- stepAIC(fit, direction = "both")
# 
# RESULT=NULL
# for (i in 0:100) {
#   cv.out = cv.glmnet(x=as.matrix(train[,2:ncol(train)]),
#                      y=as.vector(train$made),
#                      type.measure="mse", 
#                      alpha=i/100)
#   alpha=i/100
#   best.lambda=cv.out$lambda.1se
#   y.test=predict(cv.out,s=best.lambda,newx=as.matrix(test[,2:ncol(test)]))
#   out.mse=mean((as.vector(test$made)-y.test)^2)
#   RESULT=rbind(RESULT,c(alpha,best.lambda,out.mse))
# }
# colnames(RESULT)=c("alpha","lambda","MSE")
# RESULT <- as.data.frame(RESULT)
# print(RESULT)
# 
# best <- RESULT[which.min(RESULT$MSE), 'MSE']
# best
# please <- predict(fit, newx = as.matrix(test[,2:ncol(test)]), type = 'response', interval = 'confidence')
# 
# median(please[,3] - please[,2])
# mean(please[,3] - please[,2])

please <- predict(best$BestModel, newdata = test, type = 'response', interval = 'confidence')

```


#Prediction Intervals for Shots
```{r}

head(please)
median(please[,3] - please[,2])
mean(please[,3] - please[,2])
```

